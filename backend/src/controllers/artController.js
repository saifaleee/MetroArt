const ArtPiece = require('../models/ArtPiece');
const User = require('../models/User');
const { uploadToS3, getPublicUrl, s3 } = require('../utils/s3Uploader');
const { promisify } = require('util');

// Create a promisified version of getObject
const getObject = (params) => {
    return new Promise((resolve, reject) => {
        s3.getObject(params, (err, data) => {
            if (err) reject(err);
            else resolve(data);
        });
    });
}; 

// Create a new art piece
exports.createArtPiece = async (req, res) => {
  const { title, description } = req.body;
  
  if (!req.file) {
    return res.status(400).json({ message: 'Image file is required' });
  }
  if (!title) {
    return res.status(400).json({ message: 'Title is required' });
  }

  try {
    // Store the S3 key (path) in the database
    const artPiece = await ArtPiece.create({
      title,
      description,
      imagePath: req.file.key, // Store the S3 key
      artistId: req.user.id, // From authMiddleware
      // verificationHash will be auto-generated by model hook
    });
    
    // Add the full image URL to the response
    const artPieceWithUrl = {
      ...artPiece.toJSON(),
      imageUrl: getPublicUrl(req.file.key)
    };
    
    res.status(201).json(artPieceWithUrl);
  } catch (error) {
    console.error("Create Art Error:", error);
    // If S3 upload succeeded but DB failed, you might want to delete the S3 object
    // For simplicity, we're not handling that rollback here
    res.status(500).json({ message: error.message || 'Server Error creating art piece' });
  }
};

// Get all art pieces (publicly accessible)
exports.getAllArtPieces = async (req, res) => {
  try {
    console.log('Fetching all art pieces...');
    const artPieces = await ArtPiece.findAll({
      include: [{ model: User, as: 'artist', attributes: ['id', 'username'] }],
      order: [['createdAt', 'DESC']],
    });
    
    console.log(`Found ${artPieces.length} art pieces`);
    
    // Add full image URLs to each art piece
    const artPiecesWithUrls = artPieces.map(artPiece => {
      const artPieceData = artPiece.toJSON();
      const imageUrl = artPieceData.imagePath ? getPublicUrl(artPieceData.imagePath) : null;
      
      console.log(`Art piece ${artPieceData.id} - Image path: ${artPieceData.imagePath}, URL: ${imageUrl}`);
      
      return {
        ...artPieceData,
        imageUrl: imageUrl
      };
    });
    
    res.json(artPiecesWithUrls);
  } catch (error) {
    console.error('Error in getAllArtPieces:', error);
    console.error('Error fetching art pieces:', error);
    res.status(500).json({ message: 'Server Error' });
  }
};

// Get a single art piece by ID
exports.getArtPieceById = async (req, res) => {
  try {
    console.log(`Fetching art piece with ID: ${req.params.id}`);
    const artPiece = await ArtPiece.findByPk(req.params.id, {
      include: [{ model: User, as: 'artist', attributes: ['id', 'username'] }]
    });
    
    if (!artPiece) {
      console.log(`Art piece ${req.params.id} not found`);
      return res.status(404).json({ error: 'Art piece not found' });
    }
    
    const artPieceData = artPiece.toJSON();
    const imageUrl = artPieceData.imagePath ? getPublicUrl(artPieceData.imagePath) : null;
    
    console.log(`Art piece ${artPieceData.id} - Image path: ${artPieceData.imagePath}, URL: ${imageUrl}`);
    
    // Add full image URL
    const artPieceWithUrl = {
      ...artPieceData,
      imageUrl: imageUrl
    };
    
    res.json(artPieceWithUrl);
  } catch (error) {
    console.error('Error fetching art piece:', error);
    res.status(500).json({ error: 'Failed to fetch art piece' });
  }
};

// Serve image directly (if needed for private objects)
exports.serveImage = async (req, res) => {
  try {
    const key = decodeURIComponent(req.params.key);
    
    // Use the access point ARN format for the bucket
    const params = {
      Key: key,
      Bucket: `arn:aws:s3:${process.env.AWS_REGION}:${process.env.S3_ACCESS_POINT_ACCOUNT_ID}:accesspoint/${process.env.S3_ACCESS_POINT_NAME}`
    };

    // Get the image from S3
    const data = await getObject(params);
    
    if (!data || !data.Body) {
      throw new Error('No image data received');
    }
    
    // Set the appropriate content type
    res.set('Content-Type', data.ContentType || 'image/jpeg');
    res.set('Cache-Control', 'public, max-age=31536000'); // Cache for 1 year
    
    // Send the image data
    res.send(data.Body);
  } catch (error) {
    console.error('Error serving image:', error);
    
    // Return a 404 error with a placeholder image
    res.redirect('https://via.placeholder.com/600x400?text=Image+Not+Found');
  }
};

// Get a single art piece by ID (publicly accessible)
exports.getArtPieceById = async (req, res) => {
  try {
    const artPiece = await ArtPiece.findByPk(req.params.id, {
      include: [{ model: User, as: 'artist', attributes: ['id', 'username'] }],
    });
    if (artPiece) {
      res.json(artPiece);
    } else {
      res.status(404).json({ message: 'Art piece not found' });
    }
  } catch (error) {
    res.status(500).json({ message: error.message || 'Server Error' });
  }
};

// Get art pieces by current user
exports.getMyArtPieces = async (req, res) => {
    try {
        const artPieces = await ArtPiece.findAll({
            where: { artistId: req.user.id },
            include: [{ model: User, as: 'artist', attributes: ['id', 'username'] }],
            order: [['createdAt', 'DESC']],
        });

        // Add full image URLs to each art piece - similar to getAllArtPieces
        const artPiecesWithUrls = artPieces.map(artPiece => {
            const artPieceData = artPiece.toJSON();
            const imageUrl = artPieceData.imagePath ? getPublicUrl(artPieceData.imagePath) : null;
            
            return {
                ...artPieceData,
                imageUrl: imageUrl
            };
        });
        
        res.json(artPiecesWithUrls);
    } catch (error) {
        console.error('Error fetching user art pieces:', error);
        res.status(500).json({ message: error.message || 'Server Error' });
    }
};


// Update an art piece (only by owner)
exports.updateArtPiece = async (req, res) => {
  const { title, description } = req.body;
  try {
    const artPiece = await ArtPiece.findByPk(req.params.id);
    if (!artPiece) {
      return res.status(404).json({ message: 'Art piece not found' });
    }
    if (artPiece.artistId.toString() !== req.user.id.toString()) {
      return res.status(401).json({ message: 'User not authorized' });
    }

    artPiece.title = title || artPiece.title;
    artPiece.description = description || artPiece.description;
    // Image update would require new S3 upload and deleting old one - more complex for MVP
    // Re-generating verification hash if critical data changes
    const dataToHash = `${artPiece.title}-${artPiece.description}-${artPiece.artistId}-${Date.now()}`;
    artPiece.verificationHash = require('crypto').createHash('sha256').update(dataToHash).digest('hex');

    await artPiece.save();
    res.json(artPiece);
  } catch (error) {
    res.status(500).json({ message: error.message || 'Server Error' });
  }
};

// Delete an art piece (only by owner)
exports.deleteArtPiece = async (req, res) => {
  try {
    const artPiece = await ArtPiece.findByPk(req.params.id);
    if (!artPiece) {
      return res.status(404).json({ message: 'Art piece not found' });
    }
    if (artPiece.artistId.toString() !== req.user.id.toString()) {
      return res.status(401).json({ message: 'User not authorized' });
    }

    // TODO: Delete image from S3 bucket as well
    // const s3 = new AWS.S3();
    // const key = artPiece.imageUrl.substring(artPiece.imageUrl.lastIndexOf('/') + 1); // simplistic key extraction
    // await s3.deleteObject({ Bucket: process.env.S3_BUCKET_NAME, Key: key }).promise();

    await artPiece.destroy();
    res.json({ message: 'Art piece removed' });
  } catch (error) {
    res.status(500).json({ message: error.message || 'Server Error' });
  }
};